# ===========================
# Dijkstra Algorithm
# ===========================
def dijkstra(start_name, finish_name):
    start = node_to_id[start_name]
    finish = node_to_id[finish_name]

    dist = [float('inf')] * n
    parent = [-1] * n
    visited = [False] * n

    dist[start] = 0

    for _ in range(n):
        u = -1
        m = float('inf')
        for i in range(n):
            if not visited[i] and dist[i] < m:
                m = dist[i]
                u = i
        if u == -1:
            break
        visited[u] = True

        for edge in graph_data:
            s = node_to_id[edge['start']]
            f = node_to_id[edge['finish']]
            w = edge['distance']

            if s == u:
                v = f
            elif f == u:
                v = s
            else:
                continue

            if dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
                parent[v] = u

    path = []
    cur = finish
    while cur != -1:
        path.append(id_to_node[cur])
        cur = parent[cur]

    path.reverse()
    return dist[finish], path

# ===========================
# เริ่มรับค่าและเรียกใช้งาน
# ===========================
graph_data = []
while True:
    start = input("Start: ")
    finish = input("Finish: ")
    distance = int(input("Distance: "))
    if distance == 0:
        break
    graph_data.append({"start": start, "finish": finish, "distance": distance})

nodes = set()
for i in graph_data:
    nodes.add(i["start"])
    nodes.add(i["finish"])

nodes = list(nodes)
nodes.sort()  # ← เพิ่ม (แก้ปัญหา set ทำให้ลำดับ node สุ่ม)

node_to_id = {nodes[i]: i for i in range(len(nodes))}
id_to_node = {i: nodes[i] for i in range(len(nodes))}
n = len(nodes)  # ต้องมี n เพื่อใช้ใน dijkstra

# รับ node เริ่มและจบ
start_node = input("Start node: ")
end_node = input("End node: ")

# เรียกใช้ dijkstra
dist, path = dijkstra(start_node, end_node)
print(f"Dijkstra: distance={dist}, path={path}")
